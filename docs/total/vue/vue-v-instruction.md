# vue的基本使用



## 1：安装
### 1.1  vue-cli安装

> 目标: 把@vue/cli模块包按到全局, 电脑拥有vue命令, 才能创建脚手架工程
```
yarn global add @vue/cli
# 或者 npm install -g @vue/cli
```

注意: 如果半天没动静(95%都是网速问题), 可以ctrl c 终止

### 1.2  查看vue脚手架版本

```
vue -V
```
**如果出现版本号就安装成功, 否则失败**

## 2：创建项目服务-启动

> 目标: 使用vue命令, 创建脚手架项目

##### 2.1 创建项目

```
# vue和create是命令, vuecli-demo是文件夹名
vue create vuecli-demo
```
*注意: 项目名不能带大写字母, 中文和特殊符号*

##### 2.2 选择模板

> 可以上下箭头选择, 弄错了ctrl+c重来
> 

![image-20220617085115414](.\img\image-20220617085115414.png)

*注意：如果要重新预自定义就选第三个选项可以重新选这 eslint 路由 vuex babel 等*

##### 2.3 选择用什么方式下载脚手架项目需要的依赖包

![image-20220617085522861](.\img\image-20220617085522861.png)

##### 2.4 最后选完后等待 

![image-20220617090018832](.\img\image-20220617090018832.png)



# VUE基本方法

### 3.1 插值语法 （声明式渲染） - 插入的某个值
> 可以利用双大括号直接在dom标签中插入内容，不必进行webapi的一系列操作

语法：
```
 {{ 表达式 }}
```

### 3.2  MVVM 设计模型 (面试必问) 🔥

#### 3.2.1 MVVM，一种软件架构模式，决定了写代码的思想和层次
- M： model数据模型 (data里定义)
- V： view视图 （html页面）
- VM： ViewModel视图模型 (vue.js源码)

#### 3.2.2 MVVM通过`数据双向绑定`让数据自动地双向同步 **不再需要操作DOM**
- V（修改视图） -> M（数据自动同步）
- M（修改数据） -> V（视图自动同步）

> 减少了DOM操作, 挺高开发效率

![image-20220617174948921](.\img\image-20220617174948921.png)

#### 3.3.1 MVC设计模式

MVC允许在不改变视图的情况下改变视图对用户输入的响应方式，用户对View的操作交给了Controller处理，在Controller中响应View的事件调用Model的接口对数据进行操作，一旦Model发生变化便通知相关视图进行更新。

**原生HTML + JS 就是这样的**

 将html看成view;js看成controller，负责处理用户与应用的交互，响应对view的操作（对事件的监听），调用Model对数据进行操作，完成model与view的同步（根据model的改变，通过选择器对view进行操作）;将js的ajax当做Model，也就是数据层，通过ajax从服务器获取数据。

![image-20220617175121903](.\img\image-20220617175121903.png)

面试口诀1

**问：简单描述一下vue的设计模式**

**答：**vue使用的mvvm设计模式。**MVVM**是`Model-View-ViewModel`缩写，也就是把`MVC`中的`Controller`演变成`ViewModel`。`Model`层代表数据模型，`View`代表UI组件，`ViewModel`是`View`和`Model`层的桥梁，数据会绑定到`viewModel`层并自动将数据渲染到页面中，视图变化的时候会通知`viewModel`层更新数据。



### 3.3 v-bind - 动态属性

- 语法：v-bind:属性名="vue变量"
- 简写：:属性名="vue变量"
```
<!-- vue指令-v-bind属性动态赋值 -->
<a v-bind:href="url"></a>
<img :src="imgSrc">
```

面试口诀2

**问：vue项目如何做代码优化**

**答：**以上问题中其中一点： 可以用require的方式引入图片，当使用到它的时候才会按需加载，而不会像import引入那样在页面创建时就会加载，加快页面初次加载效率

### 3.4 v-on (事件绑定)
>给标签绑定事件
>常用@事件名, 给dom标签绑定事件, 以及=右侧事件处理函数

**语法：**
- v-on:事件名="要执行的==少量代码==" **（尽量不要这么写）**
- v-on:事件名="methods中的函数"
- v-on:事件名="methods中的函数(实参)"

**简写:**
- @事件名="methods中的函数(实参)"

### 3.5 v-on获取事件对象

> vue事件处理函数中, 拿到事件对象

语法:
- 无传参, 通过形参直接接收
- 传参, 通过`$event`指代事件对象传给事件处理函数

```
<template>
<div>
    <a @click="one" href="http://www.baidu.com">百度</a>
    <hr />
    <a @click="two(10, $event)" href="http://www.taobao.com">淘宝</a>
</div>
</template>
<script>
    export default {
        methods: {
            // 1. 事件触发, 无传值, 可以直接获取事件对象是
            one(e){
                console.log(e)
                e.preventDefault()
            },
            // 2. 事件触发, 传值, 需要手动传入$event
            two(num, e){
                console.log(e)
                e.preventDefault()
            }
        }
    };
</script>
```

> 思考：有没有方式可以不用写`e.preventDefault()`就可以阻止默认行为呢？

### 3.6 v-on修饰符

语法:
- @事件名.修饰符="methods里函数"
  - .stop - 阻止事件冒泡
  - .prevent - 阻止默认行为
  - .once - 程序运行期间, 只触发一次事件处理函数

> 思考： 以前是如何监听键盘事件的？

### 3.7 v-on 按键修饰符
> 给键盘事件, 添加修饰符

**语法:**
 - @keyup.enter - 监测回车按键
 - @keyup.esc - 监测返回按键
 - [更多修饰符](https://cn.vuejs.org/v2/guide/events.html#按键修饰符)

> 多使用事件修饰符, 可以提高开发效率, 少去自己判断过程

有一个翻转世界的案例：
```
 // 3. 截取字符串返回数组
        // let arr = this.msg.split("")
 // 4. 翻转
        // arr.reverse()
 // 5. 数组拼接起来
        // this.msg = arr.join("")
 // 简写
 	this.message = this.message.split("").reverse().join("")
```

### 3.8 v-model
> 把value属性和vue数据变量, 双向绑定到一起

#### 3.8.1 基本用法

- 语法: v-model="vue数据变量"
- 双向数据绑定
  - 数据变化 -> 视图自动同步
  - 视图变化 -> 数据自动同步

- v-model常用在在表单标签上，后续也会应用于某些组件
- v-model的作用是把Vue的数据变量和表单的value属性双向绑定在一起

> 思考：下拉选择框、单选框、复选框、文本域的v-model改放在哪呢？

1. 下拉选择框
v-model作用于select标签中，记录当前选择的option的值
2. 复选框，单选框
注意：复选框的值（v-model）需要用数组来包裹！
3. 文本域
和普通的input文本框一样

面试口诀3

**问：vue双向编订实现原理**

**答：**当一个Vue实现创建时，Vue会遍历data选项的属性，用`Object.defineProperty`将它们转化为`getter/setter`并且在内部追踪相关依赖，在属性被访问拒绝和修改时通知变化。每个组件实例都有相应的watcher程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。

### 3.9 v-model 的 修饰符

语法: `v-model.修饰符="vue数据变量"`

- `.number` 以parseFloat转成数字类型（会自动清除非数字及以后部分）
- `.trim` （常用） 去除首尾空白字符
- `.lazy` 在change时触发而非input时（一切可以触发change事件的情况，如失焦）

### 3.10 v-text 和 v-html 
> 作用: 更新DOM对象的innerText/innerHTML
> 注意： v-text或v-html会覆盖标签内的所有子元素

语法:

- v-text="vue数据变量"
- v-html="vue数据变量"

### 3.11 v-show 和 v-if 

> 控制标签的显示和隐藏

- 语法:
  - v-show="vue变量"
  - v-if="vue变量"
- 原理
  - v-show 用的display:none隐藏 (频繁切换使用)
  - v-if 直接从DOM树上移除
- 高级
  - v-else使用
- 使用场景及区别
  - v-show 一般用于单个没有子元素或者子元素都是静态元素的标签
  - v-if 常用于弹窗表单

### 3.11 v-for

> 渲染列表数据时，直接在标签结构中进行数组遍历
> 循环时需要给v-for当前标签加上一个key属性，用来表现每个被循环出来的标签结构唯一且不同

- 语法 （类比forEach）

  - v-for="(值, 索引) in 目标结构"
  - v-for="值 in 目标结构"

- 目标结构:

  - 可以遍历数组 / 对象 / 数字 / 字符串 (可遍历结构)

- 注意:

  v-for的临时变量名不能用到v-for范围外

补充： 避免v-for和v-if同时使用

 当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。这意味着 v-if 将分别重复运行于 每个 v-for 循环中，即先运行 v-for 的循环，然后在每一个 v-for 的循环中，再进行 v-if 的条件对比，会造成性能问题，影响速度

**解决方法：在v-for前对数组进行筛选**



#### 3.11.1 v-for 更新检测

> 原因: 当v-for遍历的目标结构改变, Vue触发v-for的更新

**口诀：**

- 数组变更方法, 就会导致v-for更新, 页面更新
- 数组非变更方法, 返回新数组, 就不会导致v-for更新, 可采用覆盖数组或this.$set()

**归纳：**

1. 这些方法会触发数组改变, v-for会监测到并更新页面

   - `push()`
   - `pop()`
   - `shift()`
   - `unshift()`
   - `splice()`
   - `sort()`
   - `reverse()`

2. 这些方法不会触发v-for更新

   - `slice()`

   - `filter()`
   - `concat()`

> 改变原数组的方法才能让v-for更新

#### 3.11.2 v-for 立即更新

> `v-for` 的默认行为会尝试原地修改元素而不是移动它们。
> 简单来说就是不删除原来的dom元素，而是尽量去修改各循环元素内部的值



### 3.12 虚拟 DOM (面试必备)

概念：.vue文件中的template里写的标签, 都是模板, 都要被vue处理成虚拟DOM对象, 才会渲染显示到真实DOM页面上

vue数据更新
   - 生成新的虚拟DOM结构
   - 和旧的虚拟DOM结构对比
   - 利用diff算法, 找不不同, 只更新变化的部分(重绘/回流)到页面

**虚拟DOM优势：**虚拟DOM保存在内存中, 只记录dom关键信息, 配合diff算法提高DOM更新的性能

### 面试背点 虚拟DOM

**问：你对虚拟DOM的理解？**

**答：**`虚拟DOM`本质上是`JavaScript`对象，是对`真实DOM`的抽象表现。状态变更时，记录新树和旧树的差异，最后把差异更新到真正的`dom`中**render函数**

1. 根据`tagName`生成父标签，读取props，设置属性， `如果有content`，设置`innerHtml或innerText`；
2. 如果存在子元素，遍历子元素递归调用render方法，将生成的子元素依次添加到父元素中，并返回根目录；



### 3.16 diff 算法

同级比较：

> vue用diff算法, 新虚拟dom, 和旧的虚拟dom比较

1. 根元素变了 ==> 删除重建
2. 根元素没有变，属性改变 ==> 元素复用，只更新新属性
> 思考： 如果标签内子标签/内容改变，diff的算法是如何对应改变的？

diff算法 - 属性 key
3. 根元素没变, 子元素没变, 元素内容改变   ==> 没有key => 就地更新
4. 有key - 值为索引  = > 就地更新
5. 有key - 值为id（不重复的值）= > 移动更新
> key的值只能是唯一不重复的, 字符串或数值

### 面试背点  diff 算法

**问：如何理解Vue中 的diff算法？**

**答：**

 在js中，渲染真是`DOM`的开销是非常大的，比如我们修改了某个数据，如果直接渲染到真实`DOM` ,会引起整个`DOM`树重绘和重排。那么有没有可能实现只更新我们修改的那一小块`DOM`二不要更新整个`DOM`呢?此时我们就需要先根据真实`DOM`生成虚拟`DOM`，当虚拟`DOM`某个节点的数据改变后会生成有一个新的`VNode`，然后新的`VNode`和旧的`VNode`作比较，发现有不一样的地方就直接修改在真实DOM上，然后旧的`VNode`的值为新的`VNode`；

 **diff**的过程就是调用`patch`函数，比较新旧节点，一边比较一边给真实的`DOM`打补丁，在采用`diff`算法比较新旧节点的时候，比较自会在同层级进行。

**问：什么是patch函数**

**答：**

 在`patch`方法中，首先进行树级别的比较`new Vnode`不存在就删除`old VNode`，`old VNode`不存在就增加新的`VNode`都存在就执行`diff`更新，当确定需要执行`diff`算法时，比较两个`VNode`，包括三种类型操作：属性更新，文本更新，子节点更新，新老节点均有子节点，则对子节点进行`diff`操作，调用`updatechidren`如果老节点没有子节点，先清空老节点的文本内容，然后为其新增子节点，如果新节点没有子节点，而老节点有子节点的时候，则移除该节点的所有子节点，老节点都没有子节点的时候，进行文本的替换。



### 3.17 动态 class

> 目标: 用v-bind给标签class设置动态的值

语法:

- :class="{类名: 布尔值}"
- :class="[类名]"

> 总结: 就是把类名保存在vue变量中赋予给标签

### 3.18 动态 style

- 语法

:style="{css属性: 值}"
:style="[css属性名: 值]"

## Vue 过滤器filter	（★★★★★）

- 一：定义使用

> 目的: 转换格式, 过滤器就是一个**函数**, 传入值返回处理后的值
> 简单理解就是在数据渲染到页面之前的过程中，进行一次包装处理

注意：过滤器只能用在, 插值表达式和v-bind表达式

**Vue中的过滤器场景：**

- 字母转大写, 输入"hello", 输出"HELLO"
- 字符串翻转, "输入hello, world", 输出"dlrow ,olleh"

**语法:**

- Vue.filter("过滤器名", (值) => {return "返回处理后的值"})
- filters: {过滤器名字: (值) => {return "返回处理后的值"}

注意：一定要有返回值

**小结：**

1. Vue中过滤器作用?
   
   1. 传入一个值, 处理后返回另外一个值
2. 过滤器的两种定义方法
   1. main.js – Vue.filter('过滤器名字', 函数体)
   2. 某.vue文件 – filters: {'过滤器名字': 函数体}
3. 如何使用过滤器?
   
   1. Vue变量 | 过滤器名字
4. 过滤器注意事项?
   
   1. 插值表达式 / 动态属性
   
- 两：传参和多过滤器
> 可同时使用多个过滤器, 或者给过滤器传参
> 从左往右依次过滤

语法:

- 过滤器传参: vue变量 | 过滤器(实参)
- 多个过滤器: vue变量 | 过滤器1 | 过滤器2

## Vue计算属性 - computed

> 场景： 页面上某一个变量是有其他两个或多个变量通过一定逻辑后运算得到的时候，可以用到计算属性进行简化

语法:

```
computed: {
    "计算属性名" () {
        return "值"
    }
}
```

**小结：**

1. 使用场景： 当变量的值, 需要通过别人计算而得来
2. 特点：函数内使用的变量改变, 重新计算结果返回
3. 注意事项：计算属性名和data里名字不能重复

### computed  缓存 （面试必背）

> 目标: 计算属性是基于它们的依赖项的值结果进行缓存的，只要依赖的变量不变, 都直接从缓存取结果
> 以上也是计算属性和方法的区别

**小结：**

1. 计算属性优势：
   1. 带缓存
   2. 依赖项不变, 直接从缓存取
   3. 依赖项改变, 函数自动执行并重新缓存
2. 因为要消耗内存，所以也是计算属性的缺点

### 面试背点

**问： 说一下computed 和 watch 的区别**

**答：（1/2）**

 **computed计算属性**该属性的结果会被缓存，当`computed`中的函数所依赖的属性没有发生改变的时候，那么调用当前函数的时候结果会从缓存中读取。除非依赖的响应式属性变化时才会重新计算，主要当做属性来使用`computed`中的函数必须用`return`返回最终的结果，`computed`更高效，优先使用

## 侦听器 - watch

> 可以侦听data/computed属性值改变

 一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 `$watch()`，遍历 watch 对象的每一个 property。

- 语法：

```
watch: {
    "被侦听的属性名" (newVal, oldVal){
        
    }
}
```

> 发现，引用类型的对象无法监听到，该怎么办

### 深度侦听和立即执行

> 侦听引用数据类型, 或者立即执行侦听函数

- 语法：
```
watch: {
    "要侦听的属性名": {
        immediate: true, // 立即执行
        deep: true, // 深度侦听复杂类型内变化
        handler (newVal, oldVal) {
            
        }
    }
}
```

> 总结: immediate立即侦听, deep深度侦听, handler固定方法触发

补充：另一个监听对象特点属性的方式

 通过设置key为对象属性的索引，value为监听回调方法的形式
```
 watch: {
    'user.name': (newVal, oldVal) => {
      console.log(newVal, oldVal)
    }
  }
```

### 面试背点 computed 和 watch 的区别

**问： 说一下computed 和 watch 的区别**

**答：（2/2）**

 **watch属性监听**是一个对象，键是需要观察的属性，值是对应回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作，监听属性的变化，需要在数据变化时执行异步或开销较大的操作使用。

 **使用场景：**`computed`当一个属性受多个属性影响的时候使用，例：购物车结算功能； `watch`当一条数据影响多条数据的时候使用，例：搜索数据。



[实例代码](https://extraordinary-palmier-f8e65a.netlify.app/#/)